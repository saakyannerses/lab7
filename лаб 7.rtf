{\rtf1\ansi\ansicpg1251\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 \uc0\u1051 \u1072 \u1073  7 \
\uc0\u1047 \u1072 \u1076 \u1072 \u1095 \u1072  1 \u1057 ++
\f1\b0 \
\
#include <iostream>\
#include <cmath>\
\
using namespace std;\
\
// \uc0\u1060 \u1091 \u1085 \u1082 \u1094 \u1080 \u1103  \u1076 \u1083 \u1103  \u1074 \u1099 \u1095 \u1080 \u1089 \u1083 \u1077 \u1085 \u1080 \u1103  \u1087 \u1088 \u1086 \u1080 \u1079 \u1074 \u1086 \u1076 \u1085 \u1086 \u1081 \
double derivative(double x, double y) \{\
    return -y + exp(x);\
\}\
\
// \uc0\u1060 \u1091 \u1085 \u1082 \u1094 \u1080 \u1103  \u1076 \u1083 \u1103  \u1074 \u1099 \u1095 \u1080 \u1089 \u1083 \u1077 \u1085 \u1080 \u1103  \u1090 \u1086 \u1095 \u1085 \u1086 \u1075 \u1086  \u1088 \u1077 \u1096 \u1077 \u1085 \u1080 \u1103 \
double exact_solution(double x) \{\
    return (exp(x) / 2) + exp(-x);\
\}\
\
int main() \{\
    double x0 = 0.0;\
    double y0 = 1.5;\
    double x_end = 1.0;\
    double h = 0.1;\
\
    double x = x0;\
    double y = y0;\
\
    cout << "x\\tEuler\\tExact\\tDifference" << endl;\
\
    while (x <= x_end) \{\
        double y_next = y + h * derivative(x, y);\
        double exact = exact_solution(x);\
        double diff = abs(y_next - exact);\
     \
     cout << x << "\\t" << y_next << "\\t" << exact << "\\t" << diff << endl;\
     \
        y = y_next;\
        x += h;\
    \}\
\
    return 0;\
\}\
\

\f0\b \uc0\u1047 \u1072 \u1076 \u1072 \u1095 \u1072  2 \u1087 \u1080 \u1090 \u1086 \u1085 \
\

\f1\b0 import math\
\
def exact_solution(x):\
    return (math.exp(-x**2) * x**2) / 2\
\
def euler_method(x0, y0, h, x_final):\
    x = x0\
    y = y0\
    \
    print("x\\t Numerical solution\\t Exact solution\\t Error")\
    \
    while x <= x_final:\
        numerical_solution = y + h * (-2*x*y + x*math.exp(-x**2))\
        error = abs(numerical_solution - exact_solution(x))\
        \
        print(f"\{x\}\\t \{y\}\\t \{exact_solution(x)\}\\t \{error\}")\
        \
        y = numerical_solution\
        x += h\
\
x0 = 0.0\
y0 = 0.0\
h = 0.1\
x_final = 1.0\
\
euler_method(x0, y0, h, x_final)}